
# **Telegram Chess Bot: Technical Spec (As-Built)**

## 1. Обзор

Цель: создан Telegram-бот для игры в шахматы против движка Stockfish. Основной упор сделан на чистый интерфейс, надёжное управление состоянием с персистентностью и поддержку одновременных игр даже после перезапуска бота.

## 2. Стек технологий

*   **Telegram Bot API:** `pytelegrambotapi` — фреймворк для взаимодействия с Telegram.
*   **Шахматная логика:** `python-chess` — для управления доской, генерации ходов, валидации.
*   **Шахматный движок:** `stockfish` — для расчёта ходов ИИ.
*   **Рендеринг доски:** `cairosvg` — для конвертации SVG в PNG в памяти.
*   **Хранение данных:** `sqlitedict` — для персистентного хранения состояний игр в файловой базе данных.

## 3. Архитектура

### 3.1. Управление состоянием (двухуровневая система)

Система обеспечивает отказоустойчивость при перезапуске бота.

*   **Горячий кэш (Runtime Cache):** Глобальный словарь `sessions: Dict[str, Any]` в оперативной памяти. Хранит несериализуемые объекты: инстанс `Stockfish` и объект `chess.Board`.
*   **Персистентное хранилище (Persistent Storage):** `CHESS_SESSIONS: SqliteDict`. Хранит сериализуемые данные игры (`fen`, `message_id`, `chat_id`, `player_color`). **Ключ — ID пользователя в виде строки (`str(user_id)`).**
*   **Принцип работы:** При любом действии игрока бот ищет сессию в кэше. Если её нет, он загружает данные из `SqliteDict`, на лету восстанавливает объекты `Stockfish` и `chess.Board` и помещает их в кэш. После каждого хода обновлённый FEN сохраняется в `SqliteDict`.

### 3.2. Управление движком Stockfish

**Принцип: один пользователь — один процесс Stockfish в активной игре.** Процесс живёт в кэше и корректно завершается командой `send_quit_command()` при окончании или сбросе игры.

## 4. Пользовательский интерфейс (UI/UX)

### 4.1. Рендеринг и обновление доски

*   **Единое сообщение:** Вся партия происходит в одном сообщении Telegram, которое редактируется (`edit_message_media`) для обновления доски и клавиатуры. Это предотвращает спам в чате.
*   **Визуальные улучшения:**
    *   **Подсветка последнего хода:** Последний ход движка подсвечивается на доске (`lastmove=move`).
    *   **Переворот доски:** Доска автоматически переворачивается (`flipped=True`), если пользователь играет за чёрных.

### 4.2. Процесс хода (Inline-клавиатура)

Ввод хода происходит в два этапа для защиты от ошибок:
1.  **Выбор фигуры:** Пользователю предлагаются кнопки с координатами всех его фигур, у которых есть легальные ходы.
2.  **Выбор поля:** После выбора фигуры клавиатура обновляется, показывая только доступные для неё поля и кнопку `« Назад`.

### 4.3. Управление игрой (Слэш-команды)

*   `/newgame`: Начать новую партию с выбором стороны (белые, чёрные, случайный цвет).
*   `/undo`: Отменить последний ход (игрока и движка).
*   `/resign`: Сдаться и немедленно завершить партию.
*   `/help`: Показать детальное сообщение со списком всех команд.

## 5. Структура прототипа

*   **Единый файл:** Весь код для прототипа размещён в одном файле для простоты тестирования и интеграции.
*   **База данных:** Файл `db/chess_sessions.db` создаётся и управляется автоматически библиотекой `SqliteDict`.
*   **Конфигурация:** Токен бота импортируется из внешнего файла `cfg.py`.

## 6. Следующие шаги (потенциальные улучшения)

*   **Настройка сложности:** Добавить команду `/difficulty` для изменения ELO движка.
*   **Обработка сбоев:** Интегрировать обработку `StockfishException` для повышения надёжности.
*   **Экспорт в PGN:** Реализовать команду `/pgn` для выгрузки нотации сыгранной партии.
*   **Модуляризация:** Для продакшена разбить код на логические модули (`game_logic.py`, `visuals.py` и т.д.).