#!/usr/bin/env python3

import random
import threading

import openai
from sqlitedict import SqliteDict

import cfg
import utils
import my_log


# Ð¿Ð°Ð¼ÑÑ‚ÑŒ Ð´Ð¸Ð°Ð»Ð¾Ð³Ð¾Ð² {id:messages: list}
CHATS = SqliteDict('db/dialogs_openrouter.db', autocommit=True)

# Ð·Ð°Ð¼ÐºÐ¸ Ð´Ð¸Ð°Ð»Ð¾Ð³Ð¾Ð² {id:lock}
CHAT_LOCKS = {}


MAX_CHAT_LINES = 20
MAX_HIST_BYTES = 7000
MAX_QUERY = 4000


def ai(prompt: str = '', timeou: int = 120, messages = None,
       model_to_use: str = 'google/gemma-7b-it:free') -> str:
    """Ð¡Ñ‹Ñ€Ð¾Ð¹ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ, Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑÑ‹Ñ€Ð¾Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚
    """

    if messages == None:
        assert prompt != '', 'prompt Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ñ‹Ð¼'
        messages = [{"role": "system", "content": """Ð¢Ñ‹ Ð¸ÑÐºÑƒÑÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ð¹ Ð¸Ð½Ñ‚ÐµÐ»Ð»ÐµÐºÑ‚ Ð¾Ñ‚Ð²ÐµÑ‡Ð°ÑŽÑ‰Ð¸Ð¹ Ð½Ð° Ð·Ð°Ð¿Ñ€Ð¾ÑÑ‹ ÑŽÐ·ÐµÑ€Ð°."""},
                    {"role": "user", "content": prompt}]

    base_url = 'https://openrouter.ai/api/v1'

    if hasattr(cfg, 'openrouter_api') and cfg.openrouter_api:
        api_key = random.choice(cfg.openrouter_api)
    else:
        return ''

    response = ''

    try:
        client = openai.OpenAI(api_key = api_key, base_url = base_url)

        completion = client.chat.completions.create(
            model = model_to_use,
            messages=messages,
            # max_tokens=max_tok,
            # temperature=temp,
            timeout=timeou
        )
        response = completion.choices[0].message.content
    except Exception as unknown_error1:
        my_log.log2(f'my_openrouter.ai: {unknown_error1}\n\nServer: {openai.base_url}')

    return response


def get_mem_as_string(chat_id_full: str) ->str:
    # Ð¾Ð±Ñ€ÐµÐ·Ð°ÐµÐ¼ Ð¸ÑÑ‚Ð¾Ñ€Ð¸ÑŽ
    try:
        CHATS[chat_id_full] = CHATS[chat_id_full][-cfg.max_hist_lines:]
    except:
        pass

    if chat_id_full in CHATS:
        messages = CHATS[chat_id_full]
        messages2 = []
        for x in messages:
            if x['content'].startswith('[Info to help you answer'):
                end = x['content'].find(']') + 1
                x['content'] = x['content'][end:]
            messages2.append(x)
        prompt = '\n'.join(f'{"ð”ð’ð„ð‘" if i["role"] == "user" else "ððŽð“" if i["role"] == "assistant" else "ð’ð˜ð’ð“ð„ðŒ"} - {i["content"]}\n' for i in messages2) or ''
        prompt = prompt.replace('\nððŽð“','ððŽð“')
    else:
        prompt = ''
    return prompt



def chat(chat_id: str, query: str) -> str:
    """
    The chat function is responsible for handling user queries and generating responses
    using the ChatGPT model.

    Parameters:
    - chat_id: str, the ID of the chat
    - query: str, the user's query
    - user_name: str, the user's name (default: 'noname')
    - lang: str, the language of the chat (default: 'ru')
    - is_private: bool, indicates whether the chat is private or not (default: True)
    - chat_name: str, the name of the chat (default: 'noname chat')

    Returns:
    - str, the response generated by the ChatGPT model
    """
    if chat_id in CHAT_LOCKS:
        lock = CHAT_LOCKS[chat_id]
    else:
        lock = threading.Lock()
        CHAT_LOCKS[chat_id] = lock

    with lock:
        # Ð² ÐºÐ°Ð¶Ð´Ð¾Ð¼ Ñ‡Ð°Ñ‚Ðµ ÑÐ²Ð¾Ñ Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð´Ð¸Ð°Ð»Ð¾Ð³Ð° Ð±Ð¾Ñ‚Ð° Ñ ÑŽÐ·ÐµÑ€Ð¾Ð¼
        if chat_id in CHATS:
            messages = CHATS[chat_id]
        else:
            messages = []
        # Ñ‚ÐµÐ¿ÐµÑ€ÑŒ ÐµÐµ Ð½Ð°Ð´Ð¾ Ð¿Ð¾Ñ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ Ñ‡Ñ‚Ð¾ Ð±Ñ‹ Ð²Ð»ÐµÐ·Ð»Ð° Ð² Ð·Ð°Ð¿Ñ€Ð¾Ñ Ðº GPT
        # Ð¿Ñ€Ð¾ÑÑ‚Ð¾ ÑƒÐ´Ð°Ð»ÑÐµÐ¼ Ð²ÑÐµ ÐºÑ€Ð¾Ð¼Ðµ max_hist_lines Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ñ…
        if len(messages) > MAX_CHAT_LINES:
            messages = messages[MAX_CHAT_LINES:]
        # ÑƒÐ´Ð°Ð»ÑÐµÐ¼ Ð¿ÐµÑ€Ð²ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ Ð² Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ð¸ Ð´Ð¾ Ñ‚ÐµÑ… Ð¿Ð¾Ñ€ Ð¿Ð¾ÐºÐ° Ð¾Ð±Ñ‰ÐµÐµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ‚Ð¾ÐºÐµÐ½Ð¾Ð² Ð½Ðµ
        # ÑÑ‚Ð°Ð½ÐµÑ‚ Ð¼ÐµÐ½ÑŒÑˆÐµ MAX_HIST_BYTES
        # ÑƒÐ´Ð°Ð»ÑÐµÐ¼ Ð¿Ð¾ 2 ÑÑ€Ð°Ð·Ñƒ Ñ‚Ð°Ðº ÐºÐ°Ðº Ð¿ÐµÑ€Ð²Ð°Ñ - Ð¿Ñ€Ð¾Ð¼Ð¿Ñ‚ Ð´Ð»Ñ Ð±Ð¾Ñ‚Ð°
        while utils.count_tokens(messages) > MAX_HIST_BYTES:
            messages = messages[2:]
        # Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð² Ð¸ÑÑ‚Ð¾Ñ€Ð¸ÑŽ Ð½Ð¾Ð²Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼
        messages = messages + [{"role":    "user",
                                "content": query}]

        current_prompt = []

        # Ð¿Ñ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¾Ñ‚Ð²ÐµÑ‚
        resp = ''
        try:
            resp = ai(prompt = '', messages = current_prompt + messages)
            if resp:
                messages = messages + [{"role":    "assistant",
                                        "content": resp}]
            else:
                # Ð½Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð´Ð¸Ð°Ð»Ð¾Ð³, Ð½ÐµÑ‚ Ð¾Ñ‚Ð²ÐµÑ‚Ð°
                # ÐµÑÐ»Ð¸ Ð² Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¸ Ð½ÐµÑ‚ Ñ‚ÐµÐºÑÑ‚Ð° (Ð³Ð»ÑŽÐº) Ñ‚Ð¾ ÑƒÐ±Ð¸Ñ€Ð°ÐµÐ¼ ÐµÐ³Ð¾
                if messages[-1]['content'].strip() == '':
                    messages = messages[:-1]
                CHATS[chat_id] = messages or []
                return ''
        # Ð±Ð¾Ñ‚ Ð½Ðµ Ð¾Ñ‚Ð²ÐµÑ‚Ð¸Ð» Ð¸Ð»Ð¸ Ð¾Ð±Ð¸Ð´ÐµÐ»ÑÑ
        except AttributeError:
            # Ð½Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð´Ð¸Ð°Ð»Ð¾Ð³, Ð½ÐµÑ‚ Ð¾Ñ‚Ð²ÐµÑ‚Ð°
            return ''
        # Ð¿Ñ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿ÐµÑ€ÐµÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð°
        except openai.BadRequestError as error2:
            my_log.log2(error2)
            return ''

        CHATS[chat_id] = messages or []

        return resp or ''


def undo(chat_id: str):
    """
    Undo the last two lines of chat history for a given chat ID.

    Args:
        chat_id (str): The ID of the chat.
    """
    if chat_id in CHAT_LOCKS:
        lock = CHAT_LOCKS[chat_id]
    else:
        lock = threading.Lock()
        CHAT_LOCKS[chat_id] = lock

    with lock:
        if chat_id in CHATS:
            CHATS[chat_id] = CHATS[chat_id][:-2]


def chat_reset(chat_id: str):
    """
    Reset the chat with the given chat_id.
    
    Parameters:
        chat_id (str): The ID of the chat to reset.
    
    Returns:
        None
    """
    if chat_id in CHAT_LOCKS:
        lock = CHAT_LOCKS[chat_id]
    else:
        lock = threading.Lock()
        CHAT_LOCKS[chat_id] = lock

    with lock:
        if chat_id in CHATS:
            CHATS[chat_id] = []


def console_chat_test():
    """
    This function is a console chat test. It allows the user to interact with a chatbot
    by entering queries in the console. The function takes no parameters.

    Parameters:
        None

    Returns:
        None
    """
    chat_id = 'test'

    while True:
        query = input('> ')
        if query == 'exit':
            break
        if query == 'clear':
            chat_reset(chat_id=chat_id)
            print('OK')
            continue
        if query == 'mem':
            print('')
            mem = [x for x in CHATS[chat_id]]
            for x in mem:
                print(x)
            print('')
            continue
        response = chat(chat_id='test', query=query)
        print(response)


if __name__ == '__main__':
    # print(ai('hi'))
    console_chat_test()